---
# Extract service files and restore Docker volumes
# Requires: final_backup_file variable

- name: Remove existing service directory (handle Docker-created files)
  shell: |
    set -e
    if [ -d "{{ service_dir }}" ]; then
      echo "Removing existing service directory..."
      # Use sudo to handle files created by Docker with root ownership
      sudo rm -rf "{{ service_dir }}"
      echo "Service directory removed"
    else
      echo "Service directory doesn't exist, skipping removal"
    fi
  args:
    executable: /bin/bash
  failed_when: false

- name: Create service directory
  file:
    path: "{{ service_dir }}"
    state: directory
    owner: karsten
    group: karsten
    mode: '0755'

- name: Create temporary directory for extraction
  tempfile:
    state: directory
    suffix: _{{ service_name }}_restore
  register: temp_restore_dir

- name: Extract backup archive
  unarchive:
    src: "{{ final_backup_file }}"
    dest: "{{ temp_restore_dir.path }}"
    remote_src: yes
    owner: karsten
    group: karsten
    extra_opts:
      - --overwrite
      - --no-same-owner
      - --no-same-permissions

- name: Check for Docker volume backups in new format (volumes directory)
  find:
    paths: "{{ temp_restore_dir.path }}/volumes"
    file_type: directory
    depth: 1
  register: volume_dirs_found
  when: temp_restore_dir.path is defined

- name: Check for Docker volume backups in old format (tar.gz files)
  find:
    paths: "{{ temp_restore_dir.path }}"
    patterns: "*.tar.gz"
    file_type: file
  register: volume_backups_found
  when: temp_restore_dir.path is defined

- name: Set volume restoration method
  set_fact:
    use_new_format: "{{ (volume_dirs_found.files | default([])) | length > 0 }}"
    use_old_format: "{{ (volume_backups_found.files | default([])) | length > 0 }}"

- name: Display volume restoration info
  debug:
    msg: |
      Volume restoration info:
      - New format volumes found: {{ (volume_dirs_found.files | default([])) | length }}
      - Old format volumes found: {{ (volume_backups_found.files | default([])) | length }}
      - Using new format: {{ use_new_format }}
      - Using old format: {{ use_old_format }}

- name: Create Docker volumes for restore (new format)
  community.docker.docker_volume:
    name: "{{ item.path | basename }}"
    state: present
  loop: "{{ volume_dirs_found.files | default([]) }}"
  when: use_new_format

- name: Create Docker volumes for restore (old format)
  community.docker.docker_volume:
    name: "{{ item.path | basename | regex_replace('\\.tar\\.gz$', '') }}"
    state: present
  loop: "{{ volume_backups_found.files | default([]) }}"
  when: use_old_format

- name: Restore Docker volumes (new format)
  community.docker.docker_container:
    name: "restore_{{ service_name }}_{{ item.path | basename }}"
    image: alpine:latest
    state: started
    detach: false
    cleanup: true
    auto_remove: true
    volumes:
      - "{{ item.path | basename }}:/volume"
      - "{{ item.path }}:/backup:ro"
    command: sh -c "cd /volume && cp -a /backup/. ."
  loop: "{{ volume_dirs_found.files | default([]) }}"
  when: use_new_format
  register: volume_restore_results_new

- name: Restore Docker volumes (old format)
  community.docker.docker_container:
    name: "restore_{{ service_name }}_{{ item.path | basename | regex_replace('\\.tar\\.gz$', '') }}"
    image: alpine:latest
    state: started
    detach: false
    cleanup: true
    auto_remove: true
    volumes:
      - "{{ item.path | basename | regex_replace('\\.tar\\.gz$', '') }}:/volume"
      - "{{ temp_restore_dir.path }}:/backup:ro"
    command: sh -c "cd /volume && tar xzf /backup/{{ item.path | basename }}"
  loop: "{{ volume_backups_found.files | default([]) }}"
  when: use_old_format
  register: volume_restore_results_old

- name: Set volume restore results
  set_fact:
    volume_restore_results: "{{ volume_restore_results_new if use_new_format else volume_restore_results_old }}"

- name: Remove volume files from temp directory (old format)
  file:
    path: "{{ item.path }}"
    state: absent
  loop: "{{ volume_backups_found.files | default([]) }}"
  when: use_old_format

- name: Remove volumes directory from temp directory (new format)
  file:
    path: "{{ temp_restore_dir.path }}/volumes"
    state: absent
  when: use_new_format

- name: Move service files to final location
  shell: |
    set -e
    echo "Restoring service files..."
    
    if [ ! -d "{{ temp_restore_dir.path }}/{{ service_name }}" ]; then
      echo "Error: Service directory not found in backup"
      exit 1
    fi
    
    # Copy all files (including hidden files)
    cp -r "{{ temp_restore_dir.path }}/{{ service_name }}"/* "{{ service_dir }}/" 2>/dev/null || true
    cp -r "{{ temp_restore_dir.path }}/{{ service_name }}"/.[!.]* "{{ service_dir }}/" 2>/dev/null || true
    
    # Set ownership and permissions recursively
    sudo chown -R karsten:karsten "{{ service_dir }}"
    sudo chmod -R u+rwX,g+rX,o+rX "{{ service_dir }}"
    
    echo "Service files restored with proper ownership"
  args:
    executable: /bin/bash

- name: Verify docker-compose file exists
  stat:
    path: "{{ compose_file }}"
  register: restored_compose
  failed_when: not restored_compose.stat.exists

- name: Start restored containers
  block:
    - name: Start containers using Docker Compose V2 module
      community.docker.docker_compose_v2:
        project_src: "{{ service_dir }}"
        state: present
      register: container_start_result
  rescue:
    - name: Start containers using shell command (fallback)
      shell: |
        if command -v docker >/dev/null 2>&1; then
          if docker compose version >/dev/null 2>&1; then
            echo "Using docker compose (V2)"
            docker compose up -d
          elif docker-compose --version >/dev/null 2>&1; then
            echo "Using docker-compose (V1)"
            docker-compose up -d
          else
            echo "No Docker Compose found"
            exit 1
          fi
        else
          echo "Docker not found"
          exit 1
        fi
      args:
        chdir: "{{ service_dir }}"
      register: container_start_result
      failed_when: container_start_result.rc != 0

- name: Wait for containers to be healthy
  pause:
    seconds: 10

- name: Verify containers are running
  block:
    - name: Check container status using Docker Compose V2 module
      community.docker.docker_compose_v2:
        project_src: "{{ service_dir }}"
        state: present
      register: container_status
  rescue:
    - name: Check container status using shell command (fallback)
      shell: |
        if command -v docker >/dev/null 2>&1; then
          if docker compose version >/dev/null 2>&1; then
            echo "Checking status with docker compose (V2)"
            docker compose ps
          elif docker-compose --version >/dev/null 2>&1; then
            echo "Checking status with docker-compose (V1)"
            docker-compose ps
          else
            echo "No Docker Compose found"
            exit 1
          fi
        else
          echo "Docker not found"
          exit 1
        fi
      args:
        chdir: "{{ service_dir }}"
      register: container_status
      failed_when: false

- name: Clean up temporary directory
  file:
    path: "{{ temp_restore_dir.path }}"
    state: absent
