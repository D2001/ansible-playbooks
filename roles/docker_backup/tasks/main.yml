---
# Main backup tasks for Docker services

# Pre-flight checks
- name: Verify service directory exists
  stat:
    path: "{{ service_dir }}"
  register: service_dir_stat
  failed_when: not service_dir_stat.stat.exists

- name: Verify docker-compose file exists
  stat:
    path: "{{ compose_file }}"
  register: compose_file_stat
  failed_when: not compose_file_stat.stat.exists

- name: Ensure backup directories exist
  file:
    path: "{{ item }}"
    state: directory
    owner: karsten
    group: karsten
    mode: '0755'
  loop:
    - "{{ backup_dir }}"
    - "{{ nas_backup_dir }}"

# Main backup process with error handling
- block:
    - name: Stop {{ service_name }} containers
      community.docker.docker_compose:
        project_src: "{{ service_dir }}"
        state: absent
      register: stop_result

    - name: Check for Docker volumes related to {{ service_name }}
      community.docker.docker_volume_info:
      register: all_volumes_result
      failed_when: false

    - name: Filter volumes for this service
      set_fact:
        service_volumes: "{{ all_volumes_result.volumes | selectattr('Name', 'match', service_name + '_.*') | map(attribute='Name') | list if all_volumes_result.volumes is defined else [] }}"

    - name: Create archive (no volumes case)
      community.general.archive:
        path: "{{ service_dir }}"
        dest: "{{ backup_dir }}/{{ backup_file }}"
        format: gz
        owner: karsten
        group: karsten
        mode: '0644'
      when: service_volumes | length == 0

    - name: Create temporary directory for volume backups
      tempfile:
        state: directory
        suffix: _{{ service_name }}_backup
      register: temp_backup_dir
      when: service_volumes | length > 0

    - name: Backup Docker volumes using Ansible Docker module
      community.docker.docker_container:
        name: "backup_{{ service_name }}_{{ item }}"
        image: alpine:latest
        state: started
        detach: false
        cleanup: true
        auto_remove: true
        volumes:
          - "{{ item }}:/volume:ro"
          - "{{ temp_backup_dir.path }}:/backup"
        command: tar czf /backup/{{ item }}.tar.gz -C /volume .
      loop: "{{ service_volumes }}"
      when: service_volumes | length > 0

    - name: Create combined archive with volumes
      shell: |
        cd "{{ service_dir | dirname }}"
        tar czf "{{ backup_dir }}/{{ backup_file }}" "{{ service_name }}"
        cd {{ temp_backup_dir.path }}
        tar czf "{{ backup_dir }}/{{ backup_file }}.tmp" *.tar.gz 2>/dev/null || true
        if [ -f "{{ backup_dir }}/{{ backup_file }}.tmp" ]; then
          cd "{{ backup_dir }}"
          tar --concatenate --file="{{ backup_file }}" "{{ backup_file }}.tmp"
          rm "{{ backup_file }}.tmp"
        fi
      when: service_volumes | length > 0

    - name: Clean up temporary backup directory
      file:
        path: "{{ temp_backup_dir.path }}"
        state: absent
      when: service_volumes | length > 0

    - name: Verify backup file was created
      stat:
        path: "{{ backup_dir }}/{{ backup_file }}"
      register: backup_stat
      failed_when: not backup_stat.stat.exists or backup_stat.stat.size < 1024

    - name: Upload Backup
      include_tasks: upload_backup.yml

    - name: Cleanup backups
      include_tasks: cleanup_backups.yml

  rescue:
    - name: Log backup failure
      debug:
        msg: "Backup failed: {{ ansible_failed_result.msg | default('Unknown error') }}"
      
    - name: Fail the playbook
      fail:
        msg: "Backup process failed, but containers will be restarted"

  always:
    - name: Start {{ service_name }} containers
      community.docker.docker_compose:
        project_src: "{{ service_dir }}"
        state: present
      register: start_result


