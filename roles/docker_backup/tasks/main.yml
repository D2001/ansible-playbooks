---
# Main backup tasks for Docker services

# Pre-flight checks
- name: Verify service directory exists
  stat:
    path: "{{ service_dir }}"
  register: service_dir_stat
  failed_when: not service_dir_stat.stat.exists

- name: Verify docker-compose file exists
  stat:
    path: "{{ compose_file }}"
  register: compose_file_stat
  failed_when: not compose_file_stat.stat.exists

- name: Ensure backup directories exist
  file:
    path: "{{ item }}"
    state: directory
    owner: karsten
    group: karsten
    mode: '0755'
  loop:
    - "{{ backup_dir }}"
    - "{{ nas_backup_dir }}"

# Main backup process with error handling
- block:
    - name: Stop {{ service_name }} containers
      block:
        - name: Stop containers using Docker Compose V2 module
          community.docker.docker_compose_v2:
            project_src: "{{ service_dir }}"
            state: absent
          register: stop_result
      rescue:
        - name: Stop containers using shell command (fallback)
          shell: |
            if command -v docker >/dev/null 2>&1; then
              if docker compose version >/dev/null 2>&1; then
                docker compose down
              elif docker-compose --version >/dev/null 2>&1; then
                docker-compose down
              else
                echo "No Docker Compose found"
                exit 1
              fi
            else
              echo "Docker not found"
              exit 1
            fi
          args:
            chdir: "{{ service_dir }}"
          register: stop_result

    - name: Check for Docker volumes related to {{ service_name }}
      shell: docker volume ls --format "{{ '{{' }}.Name{{ '}}' }}" | grep "^{{ service_name }}_"
      register: volumes_result
      failed_when: false

    - name: Filter volumes for this service
      set_fact:
        service_volumes: "{{ volumes_result.stdout_lines if volumes_result.rc == 0 else [] }}"

    - name: Create archive (no volumes case)
      community.general.archive:
        path: "{{ service_dir }}"
        dest: "{{ backup_dir }}/{{ backup_file }}"
        format: gz
        owner: karsten
        group: karsten
        mode: '0644'
      when: service_volumes | length == 0

    - name: Create temporary directory for volume backups
      tempfile:
        state: directory
        suffix: _{{ service_name }}_backup
      register: temp_backup_dir
      when: service_volumes | length > 0

    - name: Backup Docker volumes
      command:
        argv:
          - docker
          - run
          - --rm
          - -v
          - "{{ item }}:/volume:ro"
          - -v
          - "{{ temp_backup_dir.path }}:/backup"
          - alpine:3.19
          - /bin/sh
          - -c
          - "tar czf /backup/{{ item }}.tar.gz -C /volume ."
      loop: "{{ service_volumes }}"
      loop_control:
        label: "{{ item }}"
      when: service_volumes | length > 0

    - name: Create combined archive with volumes
      shell: |
        set -euo pipefail
        BACKUP_TAR_GZ="{{ backup_dir }}/{{ backup_file }}"
        BACKUP_TAR="${BACKUP_TAR_GZ%.gz}"
        SERVICE_DIR_NAME="{{ service_dir | basename }}"
        SERVICE_PARENT="{{ service_dir | dirname }}"
        TEMP_DIR="{{ temp_backup_dir.path }}"

        rm -f "$BACKUP_TAR" "$BACKUP_TAR_GZ"

        cd "$SERVICE_PARENT"
        tar cf "$BACKUP_TAR" "$SERVICE_DIR_NAME"

        cd "$TEMP_DIR"
        if ls *.tar.gz >/dev/null 2>&1; then
          rm -rf volumes
          mkdir -p volumes
          for volume_backup in *.tar.gz; do
            volume_name=$(basename "$volume_backup" .tar.gz)
            mkdir -p "volumes/$volume_name"
            tar xzf "$volume_backup" -C "volumes/$volume_name"
          done

          unreadable_files=$(find volumes -type f ! -perm -u+r -print)
          if [ -n "$unreadable_files" ]; then
            echo "âš  Skipping unreadable files during archive packaging:" >&2
            while IFS= read -r file; do
              printf '  - %s\n' "$file" >&2
            done <<< "$unreadable_files"
          fi

          tar --append --ignore-failed-read -f "$BACKUP_TAR" -C "$TEMP_DIR" volumes
        fi

        gzip -f "$BACKUP_TAR"
      when: service_volumes | length > 0
      args:
        executable: /bin/bash

    - name: Clean up temporary backup directory
      file:
        path: "{{ temp_backup_dir.path }}"
        state: absent
      when: service_volumes | length > 0

    - name: Verify backup file was created
      stat:
        path: "{{ backup_dir }}/{{ backup_file }}"
      register: backup_stat
      failed_when: not backup_stat.stat.exists or (backup_stat.stat.size | default(0)) == 0

    - name: Upload Backup
      include_tasks: upload_backup.yml

    - name: Cleanup backups
      include_tasks: cleanup_backups.yml

  rescue:
    - name: Log backup failure
      debug:
        msg: "Backup failed: {{ ansible_failed_result.msg | default('Unknown error') }}"
      
    - name: Fail the playbook
      fail:
        msg: "Backup process failed, but containers will be restarted"

  always:
    - name: Start {{ service_name }} containers
      block:
        - name: Start containers using Docker Compose V2 module
          community.docker.docker_compose_v2:
            project_src: "{{ service_dir }}"
            state: present
          register: start_result
      rescue:
        - name: Start containers using shell command (fallback)
          shell: |
            if command -v docker >/dev/null 2>&1; then
              if docker compose version >/dev/null 2>&1; then
                docker compose up -d
              elif docker-compose --version >/dev/null 2>&1; then
                docker-compose up -d
              else
                echo "No Docker Compose found"
                exit 1
              fi
            else
              echo "Docker not found"
              exit 1
            fi
          args:
            chdir: "{{ service_dir }}"
          register: start_result


