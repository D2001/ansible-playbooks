---
# Main backup tasks for Docker services

# Pre-flight checks
- name: Verify service directory exists
  stat:
    path: "{{ service_dir }}"
  register: service_dir_stat
  failed_when: not service_dir_stat.stat.exists

- name: Verify docker-compose file exists
  stat:
    path: "{{ compose_file }}"
  register: compose_file_stat
  failed_when: not compose_file_stat.stat.exists

- name: Ensure backup directories exist
  file:
    path: "{{ item }}"
    state: directory
    owner: karsten
    group: karsten
    mode: '0755'
  loop:
    - "{{ backup_dir }}"
    - "{{ nas_backup_dir }}"

# Main backup process with error handling
- block:
    - name: Stop {{ service_name }} containers
      shell: docker compose down
      args:
        chdir: "{{ service_dir }}"
      register: stop_result

    - name: Check for Docker volumes related to {{ service_name }}
      shell: docker volume ls --format "{% raw %}{{.Name}}{% endraw %}" | grep "{{ service_name }}" || true
      register: docker_volumes_result
      failed_when: false
      changed_when: false

    - name: Set service volumes fact
      set_fact:
        service_volumes: "{{ docker_volumes_result.stdout_lines | default([]) }}"

    - name: Create archive (no volumes case)
      community.general.archive:
        path: "{{ service_dir }}"
        dest: "{{ backup_dir }}/{{ backup_file }}"
        format: gz
        owner: karsten
        group: karsten
        mode: '0644'
      when: service_volumes | length == 0

    - name: Create temporary directory for volume backups
      tempfile:
        state: directory
        suffix: _{{ service_name }}_backup
      register: temp_backup_dir
      when: service_volumes | length > 0

    - name: Backup Docker volumes
      shell: |
        docker run --rm \
          -v {{ item }}:/volume:ro \
          -v {{ temp_backup_dir.path }}:/backup \
          alpine:latest \
          tar czf /backup/{{ item }}.tar.gz -C /volume .
      loop: "{{ service_volumes }}"
      when: service_volumes | length > 0

    - name: Create combined archive with volumes
      shell: |
        cd "{{ service_dir | dirname }}"
        tar czf "{{ backup_dir }}/{{ backup_file }}" "{{ service_name }}"
        cd {{ temp_backup_dir.path }}
        tar czf "{{ backup_dir }}/{{ backup_file }}.tmp" *.tar.gz 2>/dev/null || true
        if [ -f "{{ backup_dir }}/{{ backup_file }}.tmp" ]; then
          cd "{{ backup_dir }}"
          tar --concatenate --file="{{ backup_file }}" "{{ backup_file }}.tmp"
          rm "{{ backup_file }}.tmp"
        fi
      when: service_volumes | length > 0

    - name: Clean up temporary backup directory
      file:
        path: "{{ temp_backup_dir.path }}"
        state: absent
      when: service_volumes | length > 0

    - name: Verify backup file was created
      stat:
        path: "{{ backup_dir }}/{{ backup_file }}"
      register: backup_stat
      failed_when: not backup_stat.stat.exists or backup_stat.stat.size < 1024

    - name: Upload Backup
      include_tasks: upload_backup.yml

    - name: Cleanup backups
      include_tasks: cleanup_backups.yml

  rescue:
    - name: Log backup failure
      debug:
        msg: "Backup failed: {{ ansible_failed_result.msg | default('Unknown error') }}"
      
    - name: Fail the playbook
      fail:
        msg: "Backup process failed, but containers will be restarted"

  always:
    - name: Start {{ service_name }} containers
      shell: docker compose up -d
      args:
        chdir: "{{ service_dir }}"
      register: start_result


